diff --git a/MessengerOnFileForLinux/FileHandling/src/FileGuardian.cpp b/MessengerOnFileForLinux/FileHandling/src/FileGuardian.cpp
index ee1008cccd19184e9d6bc6270291747dd6038406..fc8eb5ae1cbe3bb253dd0a8185d6123d2e7fe3b2 100644
--- a/MessengerOnFileForLinux/FileHandling/src/FileGuardian.cpp
+++ b/MessengerOnFileForLinux/FileHandling/src/FileGuardian.cpp
@@ -1,38 +1,51 @@
-#include "FileGuardian.hpp"
-#include "FileHandling.hpp"
+#include <FileGuardian.hpp>
+#include <FileHandling.hpp>
 
-bool guard::setFileFlag(const std::string & fileName, FileFlagType type)
-{
+bool FileFlag::setFileFlag(FileFlagType type, const std::string & pathToFile, const std::string & fileName)
+{    
     if (FileFlagType::guardian == type)
     {
-        return createFile("GUARDIAN_" + fileName);
+        return FileInterface::createFile("GUARDIAN_" + fileName, pathToFile);
+    }
+    else if (FileFlagType::newMessage == type)
+    {
+        return FileInterface::createFile("newMessage", pathToFile);
     }
-    else if (FileFlagType::newFlag == type)
+    else if (FileFlagType::refuseChatInvitation == type)
     {
-        return createFile("newMessage");
+        return FileInterface::createFile("refusal", pathToFile);
     }
 }
 
-bool guard::removeFileFlag(const std::string & fileName, FileFlagType type)
+bool FileFlag::removeFileFlag(FileFlagType type, const std::string & pathToFile, const std::string & fileName)
 {
     if (FileFlagType::guardian == type)
     {
-        return removeFile("GUARDIAN_" + fileName);
+        return FileInterface::removeFile("GUARDIAN_" + fileName, pathToFile);
+    }
+    else if (FileFlagType::newMessage == type)
+    {
+        return FileInterface::removeFile("newMessage", pathToFile);
     }
-    else if (FileFlagType::newFlag == type)
+    else if (FileFlagType::refuseChatInvitation == type)
     {
-        return removeFile("newMessage");
+        return FileInterface::removeFile("refusal", pathToFile);
     }
 }
 
-bool guard::isGuardExist(const std::string & fileName, FileFlagType type)
+bool FileFlag::isFlagExist(FileFlagType type, const std::string & pathToFile, const std::string & fileName)
 {
     if (FileFlagType::guardian == type)
     {
-        return !isFileExists("GUARDIAN_" + fileName);
+        return FileInterface::isFileExists("GUARDIAN_" + fileName, pathToFile);
+    }
+    else if (FileFlagType::newMessage == type)
+    {
+        return FileInterface::isFileExists("newMessage", pathToFile);
     }
-    else if (FileFlagType::newFlag == type)
+    else if (FileFlagType::refuseChatInvitation == type)
     {
-        return removeFile("newMessage");
+        return FileInterface::isFileExists("refusal", pathToFile);
     }
 }
+
diff --git a/MessengerOnFileForLinux/FileHandling/src/FileGuardian.hpp b/MessengerOnFileForLinux/FileHandling/src/FileGuardian.hpp
index 32dd341861a6dec1eca9698c04f038070452d1d4..a7aa9513b3e7668f130f68ce31578a48600b66b9 100644
--- a/MessengerOnFileForLinux/FileHandling/src/FileGuardian.hpp
+++ b/MessengerOnFileForLinux/FileHandling/src/FileGuardian.hpp
@@ -1,11 +1,16 @@
 #pragma once
 #include <string>
 
-#include "GlobalVariables.hpp"
+enum class FileFlagType
+{
+    guardian,
+    newMessage,
+    refuseChatInvitation
+};
 
-namespace guard
+namespace FileFlag
 {
-    bool isGuardExist(const std::string & fileName, FileFlagType type);
-    bool setFileFlag(const std::string & fileName, FileFlagType type);
-    bool removeFileFlag(const std::string & fileName, FileFlagType type);
+    bool isFlagExist(FileFlagType type, const std::string& pathToFile = "", const std::string& fileName = "");
+    bool setFileFlag(FileFlagType type, const std::string& pathToFile = "", const std::string& fileName = "");
+    bool removeFileFlag(FileFlagType type, const std::string& pathToFile = "", const std::string& fileName = "");
 }
diff --git a/MessengerOnFileForLinux/FileHandling/src/FileHandling.cpp b/MessengerOnFileForLinux/FileHandling/src/FileHandling.cpp
index ef2e6e65e7a4e3492013eea78d09732a28926701..3c7dc5d9b70aa2604e62b2cb1a1c3e4370a829f2 100644
--- a/MessengerOnFileForLinux/FileHandling/src/FileHandling.cpp
+++ b/MessengerOnFileForLinux/FileHandling/src/FileHandling.cpp
@@ -1,14 +1,16 @@
-#include "FileHandling.hpp"
-#include "FileGuardian.hpp"
 #include <iostream>
 #include <cstdlib>
+#include <stdio.h>
+#include <stdlib.h>
 
+#include <FileHandling.hpp>
+#include <FileGuardian.hpp>
 
-
-bool addRow(const  std::string & fileName, const std::string & text, const std::string & pathToFile = "")
+bool FileInterface::addRow(const std::string& fileName, const std::string& text, const std::string& pathToFile)
 {
     const std::string fileLocation = pathToFile + fileName;
-    if (std::unique_ptr< std::fstream> file = openFileToSave(fileLocation))
+
+    if (std::unique_ptr<std::fstream> file = openFileToSave(fileLocation))
     {
         *file << text;
         *file << '\n';
@@ -18,42 +20,67 @@ bool addRow(const  std::string & fileName, const std::string & text, const std::
     else
     {
         return false;
-        //TODO error
+        //TODO mwozniak error
         //skad wiemy czy plik nieistenije czy jest guearian?
     }
 }
 
 
-bool closeFile(const std::string & fileToClose, const std::string & pathToFile)
+bool FileInterface::closeFile(const std::string& fileName, const std::string& pathToFile)
 {    
-    guard::removeFileFlag(fileToClose, FileFlagType::guardian, pathToFile);
+    FileFlag::removeFileFlag(FileFlagType::guardian, pathToFile, fileName);
 }
 
-bool createFile(const std::string & fileName, const std::string & pathToFile)
+bool FileInterface::createFile(const std::string& fileName, const std::string& pathToFile)
 {
-    std::ofstream fileToCreate(fileName, pathToFile);
-    fileToCreate << " ";
+    const std::string fileLocation = pathToFile + fileName;
+    std::string systemCommand = "touch " + fileLocation;
+    system(systemCommand.c_str());
+
     return isFileExists(fileName, pathToFile);
 }
 
-bool getFileAccess(const std::string & fileName, const std::string & pathToFile)
+bool FileInterface::getFileAccess(const std::string& fileName, const std::string& pathToFile)
 {
-    return guard::isGuardExist(fileName, FileFlagType::guardian, pathToFile);
+    return !FileFlag::isFlagExist(FileFlagType::guardian, pathToFile, fileName);
 }
 
-std::unique_ptr< std::string> getRowField(const std::string & field, const int fieldNumber)
+std::unique_ptr<std::vector<std::string>> FileInterface::getFilesNames(const std::string& pathToDir)
+{
+    std::string command = "ls " + pathToDir;
+    std::string commandOutput = System::getStdoutFromCommand(command);
+
+    std::unique_ptr<std::vector<std::string>> filesNames = std::make_unique<std::vector< std::string>>();
+    std::string fileName;
+
+    for (auto& x : commandOutput)
+    {
+        if (20 < x ) //ASCI bo byl problem z ' '
+        {
+            fileName += x;
+        }
+        else
+        {
+            filesNames->push_back(fileName);
+            fileName.clear();
+        }
+    }
+    return filesNames;
+
+}
+
+std::unique_ptr<std::string> FileInterface::getRowField(const std::string& field, const int fieldNumber)
 {
     int actualFieldNumber = -1;
-    std::unique_ptr< std::string> fieldToDownload = std::make_unique<std::string>();
-    for (auto &x : field)
+    std::unique_ptr<std::string> fieldToDownload = std::make_unique<std::string>();
+
+    for (auto& x : field)
     {
         if ('[' == x)
         {
             ++actualFieldNumber;
-            continue;
         }
-
-        if (actualFieldNumber == fieldNumber && ']' != x)
+        else if (actualFieldNumber == fieldNumber && ']' != x)
         {
             fieldToDownload -> push_back(x);
         }
@@ -61,28 +88,33 @@ std::unique_ptr< std::string> getRowField(const std::string & field, const int f
     return fieldToDownload;
 }
 
-bool isFileExists(const std::string & fileName, const std::string & pathToFile)
+bool FileInterface::isFileExists(const std::string& fileName, const std::string& pathToFile)
 {
     const std::string fileLocation = pathToFile + fileName;
     std::ifstream file(fileLocation);
     return file.good();
 }
 
-std::unique_ptr <std::fstream> openFileToRead(const std::string & fileName, const std::string & pathToFile = "")
+std::unique_ptr<std::fstream> FileInterface::openFileToRead(const std::string& fileName, const std::string& pathToFile)
 {
     const std::string fileLocation = pathToFile + fileName;
 
     if (!isFileExists(fileName, pathToFile))
     {
-        std::cerr << "File " + fileName + " does not exist" << std::endl;
-        return nullptr; //TODO error
+        std::cerr << "File " + fileName + " does not exist in the selected location. " << std::endl;
+        return nullptr; //TODO mwozniak error
     }
+
     if (getFileAccess(fileName, pathToFile))
-        guard::setFileFlag(fileName, FileFlagType::guardian, pathToFile);
+    {
+        FileFlag::setFileFlag(FileFlagType::guardian, pathToFile, fileName);
+    }
     else
-        return nullptr;
+    {
+        return nullptr; //TODO mwozniak errror
+    }
 
-    std::unique_ptr <std::fstream> fileToOpen= std::make_unique< std::fstream>();
+    std::unique_ptr<std::fstream> fileToOpen= std::make_unique<std::fstream>();
     fileToOpen->open(fileLocation, std::ios::in);
 
     if (fileToOpen->is_open())
@@ -91,25 +123,30 @@ std::unique_ptr <std::fstream> openFileToRead(const std::string & fileName, cons
     }
     else
     {
-        return nullptr;
+        return nullptr; //TODO mwozniak errror
     }
 }
 
-std::unique_ptr <std::fstream> openFileToSave(const std::string & fileName, const std::string & pathToFile = "")
+std::unique_ptr<std::fstream> FileInterface::openFileToSave(const std::string& fileName, const std::string& pathToFile)
 {
     const std::string fileLocation = pathToFile + fileName;
 
     if (!isFileExists(fileName, pathToFile))
     {
-        std::cerr << "File " + fileName + " does not exist" << std::endl;
-        return nullptr; //TODO error
+        std::cerr << "File " + fileName + " does not exist in the selected location. " << std::endl;
+        return nullptr; //TODO mwozniak errror
     }
+
     if (getFileAccess(fileName, pathToFile))
-        guard::setFileFlag(fileName, FileFlagType::guardian, pathToFile);
+    {
+        FileFlag::setFileFlag(FileFlagType::guardian, pathToFile, fileName);
+    }
     else
-        return nullptr;
+    {
+        return nullptr; //TODO mwozniak errror
+    }
 
-    std::unique_ptr <std::fstream> fileToOpen= std::make_unique< std::fstream>();
+    std::unique_ptr<std::fstream> fileToOpen= std::make_unique<std::fstream>();
     fileToOpen->open(fileLocation, std::ios::out | std::ios::app);
 
     if (fileToOpen->is_open())
@@ -118,28 +155,29 @@ std::unique_ptr <std::fstream> openFileToSave(const std::string & fileName, cons
     }
     else
     {
-        return nullptr;
+        return nullptr; //TODO mwozniak errror
     }
 }
 
 
-bool removeFile(const std::string & fileName, const std::string & pathToFile)
+bool FileInterface::removeFile(const std::string& fileName, const std::string& pathToFile)
 {
     const std::string fileLocation = pathToFile + fileName;
     const char * c = fileLocation.c_str();
     return ! std::remove(c); // 0 when success
+    //TODO mwozniak mnurzynski czy moze usuwac systemowo przez rm ?
 }
 
 
-std::unique_ptr< std::vector< std::string>> returnFileContent(const std::string & fileName, const std::string & pathToFile)
+std::unique_ptr<std::vector<std::string>> FileInterface::returnFileContent(const std::string& fileName, const std::string& pathToFile)
 {
-    std::unique_ptr< std::vector< std::string>> fileContent = std::make_unique< std::vector< std::string>>();
+    std::unique_ptr<std::vector<std::string>> fileContent = std::make_unique<std::vector<std::string>>();
 
-    if (std::unique_ptr< std::fstream> file = openFileToRead(fileName, pathToFile))
+    if (std::unique_ptr<std::fstream> file = openFileToRead(fileName, pathToFile))
     {
         while (!file->eof())
         {
-            std::string row; //osobna funkcja na to ?
+            std::string row;
             std::getline(*file, row);
             fileContent -> push_back(row);
         }
@@ -147,17 +185,19 @@ std::unique_ptr< std::vector< std::string>> returnFileContent(const std::string
     else
     {
         return nullptr;
-        //TODO error + removeGuard
+        //TODO mwozniak error + removeGuard
     }
-    //file juz tu nie istnieje, wiec plik zostal zamkiety
-    closeFile(fileName, pathToFile); //close file usuwa guardiana, jak to nazwac?
+                                      //TODO mwozniak mnurzyn
+    closeFile(fileName, pathToFile); //close file usuwa guardiana, moze jednak jakas nazwa na to?
+    //nie potrzebujemy funkcji ktora wykonuje operacje zamykania bo wykonuje sie to w memencie destrukcji obiektu fstream
     return fileContent;
 }
 
-std::unique_ptr<std::string> removeRowField(const std::string & row, const int fieldNumber)
+std::unique_ptr<std::string> FileInterface::removeRowField(const std::string& row, const int fieldNumber)
 {
     int actualFieldNumber = -1;
-    std::unique_ptr< std::string> rowWithoutRemovedField = std::make_unique<std::string>();
+    std::unique_ptr<std::string> rowWithoutRemovedField = std::make_unique<std::string>();
+
     for (auto &x : row)
     {
         if ('[' == x)
@@ -170,48 +210,53 @@ std::unique_ptr<std::string> removeRowField(const std::string & row, const int f
             rowWithoutRemovedField -> push_back(x);
         }
     }
+
     return rowWithoutRemovedField;
 }
 
 
-bool removeRow(const std::string & fileName, const std::string pattern, const std::string & pathToFile)
+bool FileInterface::removeRow(const std::string& fileName, const std::string& pattern, const std::string& pathToFile)
 {    
     if (!getFileAccess(fileName, pathToFile))
     {
         return false;
     }
 
+    FileFlag::setFileFlag(FileFlagType::guardian, pathToFile, fileName);
     const std::string fileLocation = pathToFile + fileName;
-    guard::setFileFlag(fileName, FileFlagType::guardian, pathToFile);
     std::string command = "sed -i -e '/" + pattern + "/d' " + fileLocation;
     std::system(command.c_str());
-    closeFile(fileName, pathToFile);
-    return true;
 
+    bool isFileClosed = closeFile(fileName, pathToFile);
+
+    return isFileClosed;
 }
 
 
-bool updateRow(const std::string & fileName, const std::string & newRow, const std::string & where, const std::string & pathToFile)
+bool FileInterface::updateRow(const std::string & fileName, const std::string & newRow, const std::string & where, const std::string & pathToFile)
 {
     if (!getFileAccess(fileName))
     {
-        return fasle;
+        return false;
     }
     const std::string fileLocation = pathToFile + fileName;
-    guard::setFileFlag(fileName, FileFlagType::guardian);
+    FileFlag::setFileFlag(FileFlagType::guardian, pathToFile, fileName);
     std::string command = "sed -i -e 's/.*" + where + ".*/" + newRow + "/g' " + fileLocation;
+    //TODO mwozniak ^zeby podmienialo tylko pierwsze znalezione wystapienie
     std::system(command.c_str());
-    closeFile(fileName, pathToFile);
-    return true;
 
+    bool isFileClosed = closeFile(fileName, pathToFile);
+
+    return isFileClosed;
 }
 
 
-std::unique_ptr<std::string> updateRowField(const std::string & row, const std::string & newField, const int fieldNumber)
+std::unique_ptr<std::string> FileInterface::updateRowField(const std::string& row, const std::string& newField, const int fieldNumber)
 {
     int actualFieldNumber = -1;
     bool flag = false;
     std::unique_ptr< std::string> rowToUpdate = std::make_unique<std::string>();
+    //TODO mwozniak jest to bardzo brzydkie, poprawic ! Ale dziala ;p
     for (auto &x : row)
     {
         if ('[' == x)
@@ -230,7 +275,7 @@ std::unique_ptr<std::string> updateRowField(const std::string & row, const std::
 
             rowToUpdate -> push_back('[');
 
-            for (auto &y : newField)
+            for (auto& y : newField)
             {
                 rowToUpdate -> push_back(y);
             }
@@ -245,21 +290,36 @@ std::unique_ptr<std::string> updateRowField(const std::string & row, const std::
 
 /** TO NIZEJ GDIZE INDZIEJ*/
 
-std::string getEnviromentalVariable( const std::string & var ) //gdzie indziej to dac
-{
-    const char * val = ::getenv( var.c_str() );
-    if ( val == 0 ) {
-        return "";
-    }
-    else {
-        return val;
-    }
-}
 
-std::string getActualDateTime()
+std::string System::getActualDateTime()
 {
     std::string dateTime = __DATE__;
     dateTime += "|";
     dateTime += __TIME__;
     return dateTime;
 }
+
+std::string System::getStdoutFromCommand(std::string cmd)
+{
+    std::string data;
+    FILE * stream;
+    const int max_buffer = 256;
+    char buffer[max_buffer];
+    cmd.append(" 2>&1");
+    stream = popen(cmd.c_str(), "r");
+
+    if (stream)
+    {
+        while (!feof(stream))
+        {
+            if (fgets(buffer, max_buffer, stream) != NULL)
+            {
+                data.append(buffer);
+            }
+        }
+
+        pclose(stream);
+    }
+
+    return data;
+}
diff --git a/MessengerOnFileForLinux/FileHandling/src/FileHandling.hpp b/MessengerOnFileForLinux/FileHandling/src/FileHandling.hpp
index 682a22a7c1d59fe8a7f106e21d5534912fae9b42..a583971f0dc3e81de2d6bac2203bd23956a1a5ef 100644
--- a/MessengerOnFileForLinux/FileHandling/src/FileHandling.hpp
+++ b/MessengerOnFileForLinux/FileHandling/src/FileHandling.hpp
@@ -4,24 +4,32 @@
 #include<string>
 #include<fstream>
 
-bool addRow(const  std::string & fileName, const std::string & text, const std::string & pathToFile = "");
-bool closeFile(const std::string & fileToClose, const std::string & pathToFile = "");
-bool createFile(const std::string & fileName, const std::string & pathToFile = "");
-bool getFileAccess(const std::string & fileName, const std::string & pathToFile = "");
-std::unique_ptr< std::string> getRowField(const std::string & field, const int fieldNumber);
-bool isFileExists(const std::string & fileName, const std::string & pathToFile = "");
-std::unique_ptr <std::fstream> openFileToRead(const std::string & fileName, const std::string & pathToFile = "");
-std::unique_ptr <std::fstream> openFileToSave(const std::string & fileName, const std::string & pathToFile = "");
-std::unique_ptr<std::string> removeRowField(const std::string & row, const int fieldNumber);
-std::unique_ptr< std::vector< std::string>> returnFileContent(const std::string & fileName, const std::string & pathToFile = "");
-bool removeRow(const std::string & fileName, const std::string pattern, const std::string & pathToFile = "");
-bool removeFile(const std::string & fileName, const std::string & pathToFile = "");
-bool updateRow(const std::string & fileName, const std::string & newRow, const std::string & where, const std::string & pathToFile = "");
-std::unique_ptr<std::string> updateRowField(const std::string & row, const std::string & newField, const int fieldNumber);
-
+namespace FileInterface
+{
+    bool addRow(const  std::string& fileName, const std::string& text, const std::string& pathToFile = "");
+    bool closeFile(const std::string& fileToClose, const std::string& pathToFile = "");
+    bool createFile(const std::string& fileName, const std::string& pathToFile = "");
+    bool getFileAccess(const std::string& fileName, const std::string& pathToFile = "");
+    std::unique_ptr<std::vector<std::string>> getFilesNames(const std::string& pathToDir = "");
+    std::unique_ptr<std::string> getRowField(const std::string& field, const int fieldNumber);
+    bool isFileExists(const std::string& fileName, const std::string& pathToFile = "");
+    std::unique_ptr<std::fstream> openFileToRead(const std::string& fileName, const std::string& pathToFile = "");
+    std::unique_ptr<std::fstream> openFileToSave(const std::string& fileName, const std::string& pathToFile = "");
+    std::unique_ptr<std::string> removeRowField(const std::string& row, const int fieldNumber);
+    std::unique_ptr<std::vector<std::string>> returnFileContent(const std::string& fileName, const std::string& pathToFile = "");
+    bool removeRow(const std::string& fileName, const std::string& pattern, const std::string& pathToFile = "");
+    bool removeFile(const std::string& fileName, const std::string& pathToFile = "");
+    bool updateRow(const std::string& fileName, const std::string& newRow, const std::string& where, const std::string& pathToFile = "");
+    std::unique_ptr<std::string> updateRowField(const std::string& row, const std::string& newField, const int fieldNumber);
+}
 
 /** wrzucic to gdzie indzie*/
-std::string getEnviromentalVariable( const std::string & var ); //DONE
-std::string getActualDateTime();//DONE
+//TODO mwozniak mnurzyn jaka nazwa ?
+namespace System
+{
+    std::string getActualDateTime();//DONE
+    std::string getStdoutFromCommand(std::string cmd);
+}
+
 
 
